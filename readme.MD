# chap1_enhanced_lexyacc

## Introduction
This repo builds and tests a version of my enhanced interpreter that is implemented using a parser that was generated by lex and yacc. It is based on the interpreter presented in chapter 1 of Samuel Kamin's book, [Programming Languages: An Interpreter-Based Approach](https://www.amazon.com/Programming-Languages-Samuel-N-Kamin/dp/0201068249/ref=sr_1_1). Kamin's original version is described at [chap1_orig](https://github.com/ddawson631/chap1_orig). My enhanced version written in Pascal is described in detail at [chap1_enhanced](https://github.com/ddawson631/chap1_enhanced). My enhanced version rewritten in C is described at [chap1_enhanced_c] (https://github.com/ddawson631/chap1_enhanced_c). In this lex/yacc version, I began with the enhanced C version and replaced its parsing logic with a parser generated from lex and yacc specification files.

My enhancements replaced the original Lisp-style syntax with a Pascal-like syntax and added new commands (load & sload) which allow instructions to be read from a file. But the overall design of the enhanced interpreter is the same as the original. It still uses the same data structures and built-in operations as the original. For a good introduction to the overall design, please read Section 1.2, entitled *The Structure of the Interpreter*, in the following document that Professor Kamin kindly provided from his textbook.

- __[Chapter 1](docs/chapter1.pdf)__ - original grammar, syntax, design & documentation

The following document compares the C vs lex/yacc versions, describes the lex and yacc specs and related changes required to use the generated parser. 

- __[Comparison](docs/comparison.pdf)__ - program organization, grammar, lex/yacc specs, old vs. ndw Unit Test results
      NOTE: If this PDF does not render well on github then please download the corresponding DOCX for a better viewing experience offline. The DOCX & PDF were created with WPS Office.

The information below presents an interactive run, Unit Test (UT) description and a listing of the Makefile.

## Interactive Run

Below is an interactive test run of the examples given in section 1.1.3 of the above chapter 1 document. The last two examples define and run a non-recursive gcd function and a recursive one.

```console
~/lexyacc/chap1$ ./chap1
Input from terminal (interactive mode)
-> 3$
3

-> 4+7$
11

-> x:=4$
4

-> x+x$
8

-> print x$
4
4

-> y:=5$
5

-> seq print x; print y; x*y qes$
4
5
20

-> if y>0 then 5 else 10 fi$
5

-> while y>0 do
>    seq x:=x+x; y:=y-1 qes
> od$
0

-> x$
128

-> fun #1 (x) := x + 1 nuf$
#1

-> #1(4)$
5

-> fun double(x):=x+x nuf$
double

-> double(4)$
8

-> x$
128

-> fun setx(x,y):= seq x:=x+y; x qes nuf$
setx

-> setx(x,1)$
129

-> x$
128

-> fun not(boolval):= if boolval then 0 else 1 fi nuf$
not

-> fun ## (x,y):= not(x=y) nuf$
##

-> fun mod(m,n):=m-n*(m/n)nuf$
mod

-> fun gcd(m,n):=
>    seq
>     r:=mod(m,n);
>     while ##(r,0) do
>      seq
>       m:=n;
>       n:=r;
>       r:=mod(m,n)
>      qes
>     od;
>     n
>    qes
>  nuf$
gcd

-> gcd(6,15)$
3

-> fun gcd(m,n):=
>    if n=0 then m else gcd(n,mod(m,n)) fi nuf$
gcd

-> gcd(6,15)$
3

-> quit$

quitting
~/lexyacc/chap1$
```

## Unit Test Strategy

The unit test (UT) script is `chap1_ut.sh`. 
The test results that it generates are saved to `chap1_ut.rs1` which is then compared to `chap1_ut.rs0`.

The extensions `.rs1` & `.rs0` stand for "result 1" & "result 0", respectively.\
The `.rs1` file contains the current result from most recent UT run.\
The `.rs0` file contains the last saved, validated result from a previous UT run. 

When the current and previous results are compared (via diff command), the only differences should be due to new or modified test cases. Unexpected differences must be investigated and corrected if necessary. Once all differences are 
confirmed to be valid then the `.rs1` file is copied to the `.rs0` file which is then saved as the latest valid result.

## UT Script

The UT cases for the enhanced C version were reused to test the lex/yacc version. The results were the same
in most cases and the differences were acceptable. Most differences are due to the different message format/content
produced by yyerror() when the parser detects syntax errors. I describe the reasons for the differences in the above
comparison document. I added some new test cases as well. 

The UT script passes load commands to the interpreter as a Here String as follows.

./chap1 <<< ")load chap1_ut.input1"

This tells the interpreter to read its instructions from `chap1_ut.input1`.
It echoes each instruction as it is read then parses and executes it. 

The UT script runs the interpreter four times to process the test data in the following four input files. 

`chap1_ut.input1` - tests cases for many valid and invalid instructions\
`chap1_ut.input2` - error cases that exceed maximum sizes\
`chap1_ut.input3` - error case for a load command inside a file being loaded - aborts program\
`chap1_ut.input4` - error case for a sload (silent load - noecho) command inside a file being loaded - aborts program

Below is the listing of the current UT script.

```sh
~/lexyacc/chap1$ cat chap1_ut.sh
#!/bin/bash
#
# Unit Test script for chap1 program
# See Backup Strategy and Log of Example Run at end of script
#

#
# Make the exe then run the unit test cases
#

name=chap1
echo "making $name"
make clean
make

#
# Run test cases, save results, diff with previous result.
# Redirection of stdout, stderr to result file follows closing brace below
#

echo -e "\nRunning $name Test Cases - Saving results to ${name}_ut.rs1.\n"

{
echo -e "./$name <<< \")load ${name}_ut.input1\""
./$name <<< ")load ${name}_ut.input1"
} > ${name}_ut.rs1 2>&1

echo -e "Rebuilding with smaller sizes to test error cases."
make testsize
echo -e "Running Tests that exceed sizes and appending results to ${name}_ut.rs1.\n"

{
echo -e "./$name <<< \")load ${name}_ut.input2\""
./$name <<< ")load ${name}_ut.input2"
} >> ${name}_ut.rs1 2>&1

echo -e "Rebuilding with normal size limits for remaining test cases."
make clean
make

echo -e "\nNested load test: Use load command to read a file containing a load command."
echo -e "An error will be displayed and the program aborts."
echo -e "Running Nested load test and appending results to ${name}_ut.rs1.\n"
{
echo -e "./$name <<< \")load ${name}_ut.input3\""
./$name <<< ")load ${name}_ut.input3"
} >> ${name}_ut.rs1 2>&1

echo -e "Nested sload test: Use load command to read a file containing a sload command."
echo -e "An error will be displayed and the program aborts."
echo -e "Running Nested sload test and appending results to ${name}_ut.rs1.\n"
{
echo -e "./$name <<< \")load ${name}_ut.input4\""
./$name <<< ")load ${name}_ut.input4"
} >> ${name}_ut.rs1 2>&1


echo -e "Running load command for file that does not exist."
echo -e "Appending results to ${name}_ut.rs1.\n"
{
echo -e "\n\nTest an open file error\n\n"
echo -e "./$name <<< \")load does_not_exist.txt\""
./$name <<< ")load does_not_exist.txt"
} >> ${name}_ut.rs1 2>&1

#
# Diff Results
# Below we compare current result (.rs1) with previous good result (.rs0).
#

echo -e "diff current result ${name}_ut.rs1 with last validated result ${name}_ut.rs0."
diff -qs ${name}_ut.rs1 ${name}_ut.rs0

#
# Backup Strategy
# If diffs are valid then copy .rs1 to .rs0 and save .rs0 as latest good result.
# Backup Makefile, source, UT script, inputs and result (.rs0) together.
#
#
# Log of running this script
#
# $ ./chap1_ut.sh
# making chap1
# rm -fv chap1 *.o lex.yy.c chap1.tab.c chap1.tab.h
# removed 'chap1'
# removed 'ch1_info.o'
# removed 'chap1.tab.o'
# removed 'lex.yy.o'
# removed 'lex.yy.c'
# removed 'chap1.tab.c'
# removed 'chap1.tab.h'
# bison -d chap1.y
# gcc  -c chap1.tab.c
# flex chap1.l
# gcc  -c lex.yy.c
# gcc  -c ch1_info.c
# gcc  -o chap1 chap1.tab.o lex.yy.o ch1_info.o -ly -ll -lm
#
# Running chap1 Test Cases - Saving results to chap1_ut.rs1.
#
# Rebuilding with smaller sizes to test error cases.
# rm -fv chap1 *.o lex.yy.c chap1.tab.c chap1.tab.h
# removed 'chap1'
# removed 'ch1_info.o'
# removed 'chap1.tab.o'
# removed 'lex.yy.o'
# removed 'lex.yy.c'
# removed 'chap1.tab.c'
# removed 'chap1.tab.h'
# make CFLAGS="-DTESTSIZE"
# make[1]: Entering directory '/home/dawsond/lexyacc/chap1'
# bison -d chap1.y
# gcc -DTESTSIZE -c chap1.tab.c
# flex chap1.l
# gcc -DTESTSIZE -c lex.yy.c
# gcc -DTESTSIZE -c ch1_info.c
# gcc -DTESTSIZE -o chap1 chap1.tab.o lex.yy.o ch1_info.o -ly -ll -lm
# make[1]: Leaving directory '/home/dawsond/lexyacc/chap1'
# Running Tests that exceed sizes and appending results to chap1_ut.rs1.
#
# Rebuilding with normal size limits for other test cases.
# rm -fv chap1 *.o lex.yy.c chap1.tab.c chap1.tab.h
# removed 'chap1'
# removed 'ch1_info.o'
# removed 'chap1.tab.o'
# removed 'lex.yy.o'
# removed 'lex.yy.c'
# removed 'chap1.tab.c'
# removed 'chap1.tab.h'
# bison -d chap1.y
# gcc  -c chap1.tab.c
# flex chap1.l
# gcc  -c lex.yy.c
# gcc  -c ch1_info.c
# gcc  -o chap1 chap1.tab.o lex.yy.o ch1_info.o -ly -ll -lm
#
# Nested load test: Use load command to read a file containing a load command.
# An error will be displayed and the program aborts.
# Running Nested load test and appending results to chap1_ut.rs1.
#
# Nested sload test: Use load command to read a file containing a sload command.
# An error will be displayed and the program aborts.
# Running Nested sload test and appending results to chap1_ut.rs1.
#
# diff current result chap1_ut.rs1 with last validated result chap1_ut.rs0.
# Files chap1_ut.rs1 and chap1_ut.rs0 are identical
```

## UT Run

Below is an example UT run followed by a listing of its result file. 
Since the UT script reports that the `.rs1` and `.rs0` files are identical (see last line below),
there is no need to copy the `.rs1` to `.rs0` in this case.

```console
~/lexyacc/chap1$ ./chap1_ut.sh
making chap1
rm -fv chap1 *.o lex.yy.c chap1.tab.c chap1.tab.h
removed 'chap1'
removed 'ch1_info.o'
removed 'chap1.tab.o'
removed 'lex.yy.o'
removed 'lex.yy.c'
removed 'chap1.tab.c'
removed 'chap1.tab.h'
bison -d chap1.y
gcc  -c chap1.tab.c
flex chap1.l
gcc  -c lex.yy.c
gcc  -c ch1_info.c
gcc  -o chap1 chap1.tab.o lex.yy.o ch1_info.o -ly -ll -lm

Running chap1 Test Cases - Saving results to chap1_ut.rs1.

Rebuilding with smaller sizes to test error cases.
rm -fv chap1 *.o lex.yy.c chap1.tab.c chap1.tab.h
removed 'chap1'
removed 'ch1_info.o'
removed 'chap1.tab.o'
removed 'lex.yy.o'
removed 'lex.yy.c'
removed 'chap1.tab.c'
removed 'chap1.tab.h'
make CFLAGS="-DTESTSIZE"
make[1]: Entering directory '/home/dawsond/lexyacc/chap1'
bison -d chap1.y
gcc -DTESTSIZE -c chap1.tab.c
flex chap1.l
gcc -DTESTSIZE -c lex.yy.c
gcc -DTESTSIZE -c ch1_info.c
gcc -DTESTSIZE -o chap1 chap1.tab.o lex.yy.o ch1_info.o -ly -ll -lm
make[1]: Leaving directory '/home/dawsond/lexyacc/chap1'
Running Tests that exceed sizes and appending results to chap1_ut.rs1.

Rebuilding with normal size limits for remaining test cases.
rm -fv chap1 *.o lex.yy.c chap1.tab.c chap1.tab.h
removed 'chap1'
removed 'ch1_info.o'
removed 'chap1.tab.o'
removed 'lex.yy.o'
removed 'lex.yy.c'
removed 'chap1.tab.c'
removed 'chap1.tab.h'
bison -d chap1.y
gcc  -c chap1.tab.c
flex chap1.l
gcc  -c lex.yy.c
gcc  -c ch1_info.c
gcc  -o chap1 chap1.tab.o lex.yy.o ch1_info.o -ly -ll -lm

Nested load test: Use load command to read a file containing a load command.
An error will be displayed and the program aborts.
Running Nested load test and appending results to chap1_ut.rs1.

Nested sload test: Use load command to read a file containing a sload command.
An error will be displayed and the program aborts.
Running Nested sload test and appending results to chap1_ut.rs1.

Running load command for file that does not exist.
Appending results to chap1_ut.rs1.

diff current result chap1_ut.rs1 with last validated result chap1_ut.rs0.
Files chap1_ut.rs1 and chap1_ut.rs0 are identical
```

## UT Result

Below is a listing of the current result file. 
A "Loading file" message is displayed at the beginning of each of the four input files mentioned earlier. 
The lines that begin with an exclamation point are comments from the input files. 

```console
~/lexyacc/chap1$ cat chap1_ut.rs0
./chap1 <<< ")load chap1_ut.input1"
Input from pipe/file (batch mode)
->
Current Directory is: /home/dawsond/lexyacc/chap1

 Loading file : chap1_ut.input1

!Redo tests from section 1.1.3 of Kamin's text using the Pascal-style syntax

3$
3

4+7$
11

x:=4$
4

x+x$
8

print x$
4
4

y:=5$
5

seq print x; print y; x*y qes$
4
5
20

if y>0 then 5 else 10 fi$
5

while y>0 do
  seq x:=x+x; y:=y-1 qes
od$
0

x$
128

fun #1 (x) := x + 1 nuf$
#1

#1(4)$
5

fun double(x):=x+x nuf$
double

double(4)$
8

x$
128

fun setx(x,y):= seq x:=x+y; x qes nuf$
setx

setx(x,1)$
129

x$
128

fun not(boolval):= if boolval then 0 else 1 fi nuf$
not

!<> cannot be a function name since < and > are delimiters.
fun <
yyerror:  Line 24: syntax error, unexpected '<', expecting NAME at '<'
> (x, y):= not(x=y) nuf$

!# is not a delimiter and can be used in a name.
fun ## (x,y):= not(x=y) nuf$
##

fun mod(m,n):=m-n*(m/n)nuf$
mod

fun gcd(m,n):=
 seq
  r:=mod(m,n);
  while ##(r,0) do
   seq
    m:=n;
    n:=r;
    r:=mod(m,n)
   qes
  od;
  n
 qes
nuf$
gcd

gcd(6,15)$
3


fun gcd(m,n):=
  if n=0 then m else gcd(n,mod(m,n)) fi nuf$
gcd

gcd(6,15)$
3


!Normal precedence and associativity are implemented.
5*3+7$
22

5+3*7$
26

14-7-3$
4

48/12/2$
2

10/0$

***** applyValueOp: divide by zero


!relational operators
5<10$
1

5>10$
0

5=5$
1

10<5$
0

10<5>-1$
1

10<5>-1=1$
1

5*3>2+2$
1

5*(3>2)+2$
7


!Unary plus and minus
10--5$
15

10++5$
15

10+-5$
5

10-+5$
5

10---5$
5

10+++5$
15

10-+--+5$
5


!Valid number range
!max positive number
max:=+9223372036854775807$
9223372036854775807

!The minimum negative number below cannot be entered directly because numbers
!are first interpreted as positive then negated.
min:=-9223372036854775808
***** 9223372036854775808 is out of range.
It must be between -9223372036854775808 and 9223372036854775807, inclusive.

yyerror:  Line 78: syntax error, unexpected ERROR at '9223372036854775808'
$

!Negate max positive number then subtract 1 to get min negative number.
min:=-9223372036854775807-1$
-9223372036854775808

max+min$
-1

!Numbers that are input directly must be in range LLONG_MIN to LLONG_MAX.
d:=99999999999999999999
***** 99999999999999999999 is out of range.
It must be between -9223372036854775808 and 9223372036854775807, inclusive.

yyerror:  Line 83: syntax error, unexpected ERROR at '99999999999999999999'
$

!Numbers that go outside of that range in calculations will wrap around.
d:=max+1$
-9223372036854775808

d:=min-1$
9223372036854775807


!Keywords cannot be redefined
fun if
yyerror:  Line 89: syntax error, unexpected IF, expecting NAME at 'if'
 (x) := x+5 nuf$

if :=
yyerror:  Line 90: syntax error, unexpected ASSIGN at ':='
 20$


!Names may contain any char that is not a delimiter and must
!not contain only digits.
!Delimiters = ' ','(',')','+','-','*','/',':','=','<','>',';',',','$','!'
~12#ab:=25$
25

~12#ab$
25

x:=15-~12#ab+7$
-3


!A string of digits is not a valid name.
fun 222
yyerror:  Line 100: syntax error, unexpected NUMBER, expecting NAME at '222'
  (x) := x+222 nuf$


!Inserting a non-delimiter char into a string of digits makes a valid name.
fun 222# (x) := x+222 nuf$
222#

222#(3)$
225

x:=100-222#(3)-50$
-175


!Inserting a delimiter in a name causes erroneous results.
a(b:=25$

yyerror:  Line 109: syntax error, unexpected '$' at '$
'


!The same name may be used for a variable and a function at the same time.
fun inc10 (x) := x+10 nuf$
inc10

inc10:=25$
25

inc10$
25

inc10(88)$
98


sum:=25$
25

fun sum(x,y):= x+y nuf$
sum

sum$
25

sum(33,44)$
77


!Multiple assignment
i:=j:=k:=25$
25

i$
25

j$
25

k$
25


!ERROR MESSAGE TESTS

!Syntax Errors

fun david(x,+
yyerror:  Line 131: syntax error, unexpected '+', expecting NAME at '+'
,z):= x+1 nuf$

fun +
yyerror:  Line 132: syntax error, unexpected '+', expecting NAME at '+'
++(x):= x+1 nuf$

abc:=)
yyerror:  Line 133: syntax error, unexpected ')' at ')'
25$


!Max NAMELENG=20 but the var and function names below have 21 chars.
abcdefghijklmnopqrstu
***** Name exceeds 20 chars, begins: abcdefghijklmnopqrstu

yyerror:  Line 136: syntax error, unexpected ERROR at 'abcdefghijklmnopqrstu'
+77-10/0+33-abc*8$

fun abcdefghijklmnopqrstu
***** Name exceeds 20 chars, begins: abcdefghijklmnopqrstu

yyerror:  Line 137: syntax error, unexpected ERROR, expecting NAME at 'abcdefghijklmnopqrstu'
(x):=x+10 nuf$


!lhs of an assignment must be a name
22:=
yyerror:  Line 140: syntax error, unexpected ASSIGN at ':='
4$


!Multiple syntax errors in a single input.
!First is reported, others skipped as parser resynchronizes with next $.
!Value of ijk is not changed.
ijk:=33$
33

ijk:=50-sum(10,*
yyerror:  Line 146: syntax error, unexpected '*' at '*'
)+25-4*3+sum(*,15)-48/4+)load bad_data.txt$

ijk$
33



!Semantic Errors
!
!Since these are not syntax errors, the parser does not call yyerror().
!Such errors are detected in the application logic and cause a value of
!zero to be assigned to the erroneous expression.
!So the values of c$, a$ and b$ below return 0 due to such errors.

!Wrong number of arguments to mod()
c:=17-10-mod(100)+25*3$

***** Wrong number of arguments to: mod

c$
0


!Division by zero.
10/0$

***** applyValueOp: divide by zero

a:=17-10/0+25*3$

***** applyValueOp: divide by zero

a$
0


!Undefined function
b:=33$
33

b:=25-10+square(3)-5$

***** Undefined function: square

b$
0


!Three semantic errors (1 undef var & 2 div by 0) in a single input
!
c:=xyz+25-10/0-3*5+10/0-8*3$

***** Undefined variable: xyz

***** applyValueOp: divide by zero


***** applyValueOp: divide by zero

c$
0


!Syntax & Semantic errors in same input
!
!Note that a syntax error prevents an expression from being evaluated.
!This is demonstrated below by inserting a syntax error in the above
!expression with three semantic errors. Since undef var & div by 0 errors
!are detected during the eval() function, they are not reported.
!Only the syntax error is reported.
!
c:=xyz+25-10/0-3*5+10/0-8*3-sum(10,*
yyerror:  Line 184: syntax error, unexpected '*' at '*'
)$


quit
quitting
./chap1 <<< ")load chap1_ut.input2"
Input from pipe/file (batch mode)
->
Current Directory is: /home/dawsond/lexyacc/chap1

 Loading file : chap1_ut.input2

!
!MAXNAMES Test Case
!
!Generates error due to exceeding MAXNAMES allowed in printNames array.
!
!To run this test, build chap1 with the command "make testsize".
!This will define the TESTSIZE macro and set MAXNAMES=28 in the
!conditional compilation logic in ch1_info.h.
!
!The program begins with 26 built-in names in printNames.
!The two assignments below will create the 27th and 28th names.
!
!The function definition tries to create the 29th name, not2, which
!triggers the "no more room for names" error.
!The two references to the name boolValue also trigger the same error.
!The expression a+b then evaluates without error.
!
a:=25$
25

b:=100$
100

fun not2
***** No more room for names

yyerror:  Line 19: syntax error, unexpected ERROR, expecting NAME at 'not2'
(boolValue
***** No more room for names
):= if boolValue
***** No more room for names
 then 0 else 1 fi nuf$

a+b$
125


quit
quitting
./chap1 <<< ")load chap1_ut.input3"
Input from pipe/file (batch mode)
->
Current Directory is: /home/dawsond/lexyacc/chap1

 Loading file : chap1_ut.input3

!
!
!Nested load Command Test
!
!Generate error due to detecting a load command inside a file
! that is being loaded.
!
!First the following not function is defined and called successfully.
!Then a load command is issued which fails because it cannot be
! issued from inside another file.
!An error message is printed and the program aborts.
!
fun not(boolval):=
  if boolval then
  0
  else
  1
  fi
nuf$
not

not(3)$
0

not(0)$
1


)load gcd_only.txt
***** Load commands cannot occur inside a file being loaded.
Remove the load command for file gcd_only.txt

./chap1 <<< ")load chap1_ut.input4"
Input from pipe/file (batch mode)
->
Current Directory is: /home/dawsond/lexyacc/chap1

 Loading file : chap1_ut.input4

!
!
!Nested sload Command Test
!
!Generate error due to detecting a sload (silent load - noecho) command
! inside a file that is being loaded.
!
!First the following not function is defined and called successfully.
!Then a sload command is issued which fails because it cannot be
! issued from inside another file.
!An error message is printed and the program aborts.
!Note that the filename in the sload command is not echoed in the result file
! due to the global variable echo being set to false when lex reads ")sload".
!
fun not(boolval):=
  if boolval then
  0
  else
  1
  fi
nuf$
not

not(3)$
0

not(0)$
1


)sload
***** Load commands cannot occur inside a file being loaded.
Remove the load command for file gcd_only.txt



Test an open file error


./chap1 <<< ")load does_not_exist.txt"
Input from pipe/file (batch mode)
-> fopen() error: No such file or directory

***** filename= does_not_exist.txt

```

## Makefile

Below is a listing of the current Makefile.

```sh
~/lexyacc/chap1$ cat Makefile
#
# Makefile for "chap1"
#
SHELL = /bin/bash
LEX = flex
YACC = bison
CC = gcc

# Default CFLAGS empty
CFLAGS =

chap1: chap1.tab.o lex.yy.o ch1_info.o
        ${CC} ${CFLAGS} -o chap1 chap1.tab.o lex.yy.o ch1_info.o -ly -ll -lm

lex.yy.o: lex.yy.c chap1.tab.h ch1_info.h
        ${CC} ${CFLAGS} -c lex.yy.c

chap1.tab.o: chap1.tab.c chap1.tab.h ch1_info.h
        ${CC} ${CFLAGS} -c chap1.tab.c

ch1_info.o: ch1_info.c ch1_info.h
        ${CC} ${CFLAGS} -c ch1_info.c

chap1.tab.c chap1.tab.h: chap1.y ch1_info.h
        ${YACC} -d chap1.y

lex.yy.c: chap1.l ch1_info.h
        ${LEX} chap1.l

.PHONY: clean testsize

clean:
        rm -fv chap1 *.o lex.yy.c chap1.tab.c chap1.tab.h

testsize: clean
        $(MAKE) CFLAGS="-DTESTSIZE"
```
